\documentclass{article}
\usepackage{graphicx} % Required for inserting images
\usepackage[utf8]{inputenc}
\usepackage[ukrainian]{babel}
\usepackage{amsmath}
\usepackage{amssymb}

\title{Міні-проєкт №2. Бот}
\author{Андрій Кривий}
\date{Грудень 2024}

\begin{document}

\maketitle

\tableofcontents

\newcommand{\quickdist}{\operatorname{quickdist}}

\section{Частовживані терміни}

\subsection{Cell}
Cell, вона ж клітинка, вона ж точка - елементарна одиниця ігрового поля.

\subsection{Field}
Це поле має вигляд матриці (типу list[list[int]]), де кожен елемент репрезентує відповідну клітинку на полі. Кожен елемент матриці $a_{i,j} = \overline{0,4}$. Кожне число має таке значення:
\begin{itemize}
    \item $0$ - пуста клітинка;
    \item $1$ - клітинка гравця, недавно зайнята;
    \item $2$ - клітинка гравця;
    \item $3$ - клітинка супротивника, недавно зайнята;
    \item $4$ - клітинка супротивника.
\end{itemize}

\subsection{Position}
Координати подаються у вигляді пари чисел $(i, j)$, де $i$ - рядок, а $j$ - колонка. Причому індексація відбувається від $0$.

\subsection{Figure}
Набір точок фігурки у вигляді множини, де кожен елемент це позиція точки.

\subsection{Quickdist}
Метрика для швидкого обчислення приблизної відстані до об'єкта за формулою $d = \max\{|x_1 - x_2|, |y_1 - y_2|\}$. Фактично половина сторони квадрата, який можна намалювати з центром у одній з точок, щоб друга лежала на одній з його сторін. Причому $\quickdist(a, b) \leq |a, b|$ (це випливає з нерівності трикутника).

\section{Принцип алгоритму}
Алгоритм полягає у виборі такої позиції фігурки, яка мінімізує сумарну відстань усіх поставлених точок до відповідних найближчих точок супротивника. Це дозволяє швидко оточити супротивника, ізолюючи його.

\section{Формалізація алгоритму}
\subsection{Функція впевненості}
Функцію впевненості можна записати так:
\[f(P) = -\sum_{p \in P}\min\{|p, q| : q\in Q\}\]
Де $Q$ - множина всіх точок супротивника, а $P$ - множина всіх точок, які потенційно будуть виставлені. Отриману функцію $f(P)$ потрібно максимізувати.

Алгоритм шукає $P$ методом перебору, тобто: перебирає усі можливі $P$, перевіряє чи відповідають вони умовам задачі, обчислює $f(P)$, а згодом обирає з усіх обчислених той, що відповідає умовам та максимізує $f(P)$.

\subsection{Пошук $\min\{|p, q| : q\in Q\}$}
Для ефективного, але при цьому простому в реалізації алгоритму пошуку цього значення, використовується пошук по спіралі (яку генерує функція \textit{expanding\_distance}). В першу чергу відбувається пошук точки $q_1 \in Q$, для якої $\quickdist(p, q_1) = 1$. Якщо такої точки не існує, то продовжуємо пошук для $\quickdist(p, q_2) = 2$ і так далі.

Рано чи пізно (якщо супротивник не існує, то буде обмеження по відстані) знайдеться така точка $q_n$, що $\quickdist(p, q_n) = n$. Тоді знаходимо всі точки $q* \in Q* \subset Q$, для яких $\quickdist(p, q_n) \leq \quickdist(p, q*) \leq |p, q_n|$ та обираємо з $\{q_n\} \cup Q*$ з мінімальним значенням відстані до $p$.

Таким чином ми знайдемо цю мінімальну відстань.

Для пришвидшення роботи програми, відбувається кешування цього значення для кожного $p$ (кеш інвалідується на кожному кроці гри).

\subsection{Перевірка чи $P$ задовільняє умови гри}
Алгоритм перевіря кожну точку $p \in P$ на ігровому полі. У випадку якщо це точка супротивника, то це розміщення точно не задовільняє умову.

Якщо ця точка це точка гравця, то ми відмічаємо прапорець перетину. І наступного разу, коли знову знайдемо такий випадок, то це розміщення знову ж таки не задовільняє умову.

Якщо ми пройшлись по усім точкам, а також якщо стоїть прапорець перетину, то дане розміщення задовільняє умову.

\section{Класифікація функцій}

\subsection{Абстрактні математичні функції}
\begin{enumerate}
    \item \textit{expanding\_distance(center)} - генерування позицій навколо точки у вигляді квадратної спіралі.
\end{enumerate}

\subsection{Функції, що відповідають за ввід/вивід (IO)}
\begin{enumerate}
    \item \textit{read\_player\_info()} - читання початкових вхідних даних з віртуальної машини (на початку роботи) і створення відношення між символами на полі та їхніми значеннями для гравця.
    \item \textit{read\_field()} - читання ігрового поля з віртуальної машини (на кожному кроці).
    \item \textit{read\_figure()} - читання фігурки.
\end{enumerate}

\subsection{Функції алгоритму}
\begin{enumerate}
    \item \textit{update(char\_map)} - викликається на кожному кроці бота.
    \item \textit{validate\_placement(position, field, figure)} - перевіряє чи можна розмістити подану фігурку в цій точці.
    \item \textit{evaluate\_placement(position, field, figure, cache, max\_confidence)} - оцінює наскільки така позиція фігурки є вигідною для гравця. Якщо впевненість менша за \textit{max\_confidence}, то повертає None.
    \item \textit{get\_distance\_at(position, field, cache)} - розраховує відстань від даної точки до найближчої точки супротивника.
\end{enumerate}

\subsection{Точка входу}
\textit{mainloop()} - містить вступний код, який ініціалізує бота, виловлює помилки у випадку програшу та викликає на кожному кроці \textit{update}

\end{document}
