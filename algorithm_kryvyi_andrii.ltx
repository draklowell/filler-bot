\documentclass{article}
\usepackage{graphicx} % Required for inserting images
\usepackage[utf8]{inputenc}
\usepackage[ukrainian]{babel}
\usepackage{amsmath}
\usepackage{amssymb}

\title{Міні-проєкт №2. Бот}
\author{Андрій Кривий}
\date{Грудень 2024}

\begin{document}

\maketitle

\tableofcontents

\newcommand{\quickdist}{\operatorname{quickdist}}

\section{Частовживані терміни}

\subsection{Cell}
Cell, вона ж клітинка, вона ж точка - елементарна одиниця ігрового поля.

\subsection{Field}
Це поле у вигляді матриці (list[list[int]]), де кожен елемент репрезентує відповідну клітинку на полі. Кожен елемент матриці $a_{i,j} = \overline{0,4}$. Кожне число має таке значення:
\begin{itemize}
    \item $0$ - пуста клітинка;
    \item $1$ - моя клітинка, недавно зайнята;
    \item $2$ - моя клітинка;
    \item $3$ - клітинка супротивника, недавно зайнята;
    \item $4$ - клітинка супротивника.
\end{itemize}

\subsection{Figure}
Схожа до поля матриця, але в ній кожен елемент приймає значення $a_{i,j} = 0,1$, де $0$ - пуста клітинка, а $1$ - заповнена.

\subsection{Quickdist}
Метрика для швидкого обчислення приблизної відстані до об'єкта за формулою $d = \max\{|x_1 - x_2|, |y_1 - y_2|\}$. Фактично половина сторони квадрата, який можна намалювати з центром у одній з точок, щоб друга лежала на одній з його сторін.

\subsection{Position}
Координати подаються у вигляді вектора $(i, j)$, де $i$ - рядок, а $j$ - колонка. При чому індексація відбувається від $0$.

\section{Опис алгоритму}
\subsection{Загальні принципи}
Алгоритм полягає у виборі такої позиція фігурки, яка мінімізує сумарну відстань усіх поставлених точок до відповідних найближчих точок супротивника.

Формально це можна записати так:
\[f(P) = -\sum_{p \in P}\min\{|p, q| : q\in Q\}\]
Де $Q$ - множина всіх точог супротивника, а $P$ - множина всіх виставлених фігурою точок. Отриману функцію $f(P)$ потрібно максимізувати.

Алгоритм шукає $P$ методом перебору, тобто: перебирає усі можливі $P$, перевіряє чи відповідають вони умовам задачі, обчислює $f(P)$, а згодом обирає з усіх обчислених той, що максимізує $f(P)$.

\subsection{Пошук $\min\{|p, q| : q\in Q\}$}
Спершу варто зазначити, що $\quickdist(p, q) \leq |p, q|$ (це випливає з нерівності трикутника).

Для ефективного, але при цьому простому в реалізації алгоритму пошуку цього значення, використовується пошук по спіралі (яку генерує функція \textit{expanding\_distance}. В першу чергу відбувається пошук точки $q_1 \in Q$, для якої $\quickdist(p, q_1) = 1$. Якщо такої точки не існує, то продовжуємо пошук для $\quickdist(p, q_2) = 2$ і так далі.

Рано чи пізно (якщо супротивник існує, інакше буде обмеження по відстані) знайдеться така точка $q_n$, що $\quickdist(p, q_n) = n$. Тоді знаходимо всі точки $q* \in Q$, для яких $\quickdist(p, q*) \leq |p, q_n|$ та обираємо з них та $q_n$ з мінімальним значенням відстані до $p$.

Таким чином ми знайдемо цю мінімальну відстань.

Для пришвидшення роботи програми, відбувається кешування цього значення для кожного $p$ (кеш інвалідується на кожному кроці гри).

\subsection{Перевірка чи $P$ задовільняє умови гри}
Алгоритм порівнює кожну точку з $P$ з точкою, яка була на ігровому полі до цього. У випадку якщо це точка супротивника, то це розміщення точно не задовільняє умову.

Якщо ця точка це точка гравця, то ми відмічаємо прапорець перетину. І наступного разу, коли знову знайдемо такий випадок, то це розміщення знову ж таки не задовільняє умову.

Якщо ми пройшлись по усім точкам, а також якщо стоїть прапорець перетину, то дане розміщення задовільняє умову.

\section{Класифікація функцій}

\subsection{Абстрактні математичні функції}
\begin{enumerate}
    \item \textit{crop\_figure(figure)} - обрізання зайвих сторін форми.
    \item \textit{expanding\_distance(center)} - генерування позицій навколо точки.
\end{enumerate}

\subsection{Функції, що відповідають за ввід/вивід (IO)}
\begin{enumerate}
    \item \textit{debug(message, end, flush)} - виведення повідомлень налагоджування.
    \item \textit{read\_player\_info()} - читання початкових вхідних даних з віртуальної машини (на початку роботи) і створення відношення між символами на полі та їхніми значеннями для гравця.
    \item \textit{read\_field()} - читання ігрового поля з віртуальної машини (на кожному кроці).
    \item \textit{read\_figure()} - читання фігурки.
\end{enumerate}

\subsection{Функції алгоритму}
\begin{enumerate}
    \item \textit{update(char\_map)} - викликається на кожному кроці бота.
    \item \textit{blit\_figure(position, field, figure)} - перевіряє чи можна розмістити подану фігурку в цій точці на полі, і якщо можна, то повертає поле з нею (нові точки позначаються відповідно).
    \item \textit{evaluate\_placement(field, cache)} - оцінити наскільки така розстановка поля є вигідною для гравця.
    \item \textit{get\_distance\_at(position, field, cache)} - розрахувати відстань від даної точки до найближчої точки противника.
\end{enumerate}

\subsection{Точка входу}
\textit{mainloop()} - містить вступний код, який ініціалізує бота, виловлює помилки у випадку програшу та викликає на кожному кроці \textit{update}
\end{document}
